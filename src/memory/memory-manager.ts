import { Env } from '../types/env';

/**
 * Represents a single entry in the conversation memory, capturing one turn of interaction.
 */
export interface MemoryEntry {
  /**
   * A unique identifier for the memory entry.
   */
  id: string;
  /**
   * The ID of the conversation this entry belongs to.
   */
  conversationId: string;
  /**
   * The input provided by the user.
   */
  userInput: string;
  /**
   * The response generated by the AI agent.
   */
  agentResponse: string;
  /**
   * The name of the agent that handled the interaction.
   */
  agentUsed: string;
  /**
   * The timestamp of the interaction in ISO 8601 format.
   */
  timestamp: string;
  /**
   * Additional metadata related to the interaction.
   */
  metadata?: Record<string, any>;
}

/**
 * Represents the complete memory state for a single conversation.
 */
export interface ConversationMemory {
  /**
   * The unique identifier for the conversation.
   */
  conversationId: string;
  /**
   * The ID of the user associated with the conversation.
   */
  userId: string;
  /**
   * An array of recent interactions in the conversation.
   */
  recentInteractions: MemoryEntry[];
  /**
   * A generated summary of the conversation.
   */
  summary: string;
  /**
   * A flexible object for storing broader conversational context.
   */
  context: Record<string, any>;
  /**
   * The timestamp of the last update in ISO 8601 format.
   */
  lastUpdated: string;
}

/**
 * Manages the persistence and retrieval of conversation memory.
 * It uses a hybrid approach with Cloudflare KV for caching and D1 for long-term storage.
 */
export class MemoryManager {
  private env: Env;

  /**
   * Creates an instance of MemoryManager.
   * @param {Env} env - The environment object containing KV and D1 bindings.
   */
  constructor(env: Env) {
    this.env = env;
  }

  /**
   * Retrieves the memory for a specific conversation.
   * It first checks the KV cache and falls back to the D1 database if not found.
   * @param {string} conversationId - The ID of the conversation to retrieve.
   * @returns {Promise<ConversationMemory | null>} A promise that resolves to the conversation memory or null if not found.
   */
  async getConversationMemory(conversationId: string): Promise<ConversationMemory | null> {
    try {
      // Try to get from KV first (faster access)
      const kvMemory = await this.env.MEMORY_KV.get(`conversation:${conversationId}`);
      if (kvMemory) {
        return JSON.parse(kvMemory);
      }

      // Fallback to D1 database
      const dbResult = await this.env.CONVERSATIONS_DB
        .prepare('SELECT * FROM conversations WHERE id = ?')
        .bind(conversationId)
        .first();

      if (dbResult) {
        const memory: ConversationMemory = {
          conversationId: dbResult.id as string,
          userId: dbResult.user_id as string,
          recentInteractions: JSON.parse(dbResult.recent_interactions as string || '[]'),
          summary: dbResult.summary as string || '',
          context: JSON.parse(dbResult.context as string || '{}'),
          lastUpdated: dbResult.last_updated as string
        };

        // Cache in KV for faster future access
        await this.env.MEMORY_KV.put(
          `conversation:${conversationId}`,
          JSON.stringify(memory),
          { expirationTtl: 3600 } // 1 hour cache
        );

        return memory;
      }

      return null;
    } catch (error) {
      console.error('Error retrieving conversation memory:', error);
      return null;
    }
  }

  /**
   * Updates the memory for a conversation with a new interaction entry.
   * @param {string} conversationId - The ID of the conversation to update.
   * @param {Omit<MemoryEntry, 'id' | 'conversationId'>} entry - The new memory entry to add.
   * @returns {Promise<void>} A promise that resolves when the memory has been updated.
   * @throws {Error} If updating the memory fails.
   */
  async updateMemory(conversationId: string, entry: Omit<MemoryEntry, 'id' | 'conversationId'>): Promise<void> {
    try {
      const memory = await this.getConversationMemory(conversationId) || {
        conversationId,
        userId: 'unknown', // Should be provided in a real implementation
        recentInteractions: [],
        summary: '',
        context: {},
        lastUpdated: new Date().toISOString()
      };

      // Add new entry
      const newEntry: MemoryEntry = {
        id: crypto.randomUUID(),
        conversationId,
        ...entry
      };

      memory.recentInteractions.push(newEntry);

      // Keep only last 10 interactions for performance
      if (memory.recentInteractions.length > 10) {
        memory.recentInteractions = memory.recentInteractions.slice(-10);
      }

      // Update summary if we have enough interactions
      if (memory.recentInteractions.length >= 3) {
        memory.summary = await this.generateSummary(memory.recentInteractions);
      }

      memory.lastUpdated = new Date().toISOString();

      // Update both KV and D1
      await Promise.all([
        this.updateKVMemory(conversationId, memory),
        this.updateD1Memory(conversationId, memory)
      ]);
    } catch (error) {
      console.error('Error updating memory:', error);
      throw error;
    }
  }

  /**
   * Updates the conversation memory in the KV cache.
   * @param {string} conversationId - The ID of the conversation.
   * @param {ConversationMemory} memory - The conversation memory object to store.
   * @returns {Promise<void>}
   * @private
   */
  private async updateKVMemory(conversationId: string, memory: ConversationMemory): Promise<void> {
    await this.env.MEMORY_KV.put(
      `conversation:${conversationId}`,
      JSON.stringify(memory),
      { expirationTtl: 3600 }
    );
  }

  /**
   * Updates the conversation memory in the D1 database.
   * @param {string} conversationId - The ID of the conversation.
   * @param {ConversationMemory} memory - The conversation memory object to store.
   * @returns {Promise<void>}
   * @private
   */
  private async updateD1Memory(conversationId: string, memory: ConversationMemory): Promise<void> {
    await this.env.CONVERSATIONS_DB
      .prepare(`
        INSERT OR REPLACE INTO conversations 
        (id, user_id, recent_interactions, summary, context, last_updated)
        VALUES (?, ?, ?, ?, ?, ?)
      `)
      .bind(
        conversationId,
        memory.userId,
        JSON.stringify(memory.recentInteractions),
        memory.summary,
        JSON.stringify(memory.context),
        memory.lastUpdated
      )
      .run();
  }

  /**
   * Generates a simple summary from recent interactions.
   * @param {MemoryEntry[]} interactions - An array of recent memory entries.
   * @returns {Promise<string>} A promise that resolves to a summary string.
   * @private
   */
  private async generateSummary(interactions: MemoryEntry[]): Promise<string> {
    // Simple summary generation - could be enhanced with LLM
    const recentTopics = interactions
      .slice(-5)
      .map(i => i.userInput)
      .join(' ');

    return `Recent conversation topics: ${recentTopics.substring(0, 200)}...`;
  }

  /**
   * Clears all memory associated with a conversation from both KV and D1.
   * @param {string} conversationId - The ID of the conversation to clear.
   * @returns {Promise<void>} A promise that resolves when the memory has been cleared.
   * @throws {Error} If clearing the memory fails.
   */
  async clearConversationMemory(conversationId: string): Promise<void> {
    try {
      await Promise.all([
        this.env.MEMORY_KV.delete(`conversation:${conversationId}`),
        this.env.CONVERSATIONS_DB
          .prepare('DELETE FROM conversations WHERE id = ?')
          .bind(conversationId)
          .run()
      ]);
    } catch (error) {
      console.error('Error clearing conversation memory:', error);
      throw error;
    }
  }
}
